/** * Specify * ======= * Version: 1.1 * https://github.com/adamdehaven/Specify * * Adam DeHaven * http://adamdehaven.com * @adamdehaven * * Additional info:  * http://adamdehaven.com/blog/2015/05/dimension-adobe-illustrator-designs-with-a-simple-script/ * ==================== */ if (app.documents.length > 0) {     // document     var doc = activeDocument;     // count selected items     var selectedItems = parseInt(doc.selection.length, 10) || 0;     /*=====================================     =            Create Dialog            =     =====================================*/     var specifyDialogBox = new Window("dialog", "Specify");      specifyDialogBox.alignChildren = "left";      // Dimension panel     dimensionPanel = specifyDialogBox.add("panel", undefined, "Select which dimension(s) to specify");     dimensionPanel.orientation = "column";     dimensionPanel.margins = 20;     // Dimension group     dimensionGroup = dimensionPanel.add("group");     dimensionGroup.orientation = "row";     // Add dimension panel checkboxes     // Top     (topCheckbox = dimensionGroup.add("checkbox", undefined, "Top")).helpTip = "Dimension the top\nside of the object(s).";     topCheckbox.value = false;     // Right     (rightCheckbox = dimensionGroup.add("checkbox", undefined, "Right")).helpTip = "Dimension the right\nside of the object(s).";     rightCheckbox.value = false;     // Bottom     (bottomCheckbox = dimensionGroup.add("checkbox", undefined, "Bottom")).helpTip = "Dimension the bottom\nside of the object(s).";     bottomCheckbox.value = false;     // Left     (leftCheckbox = dimensionGroup.add("checkbox", undefined, "Left")).helpTip = "Dimension the left\nside of the object(s).";     leftCheckbox.value = false;     selectAllGroup = dimensionPanel.add("group");     selectAllGroup.orientation = "row";     // Select All     (selectAllCheckbox = selectAllGroup.add("checkbox", undefined, "Select All")).helpTip = "Dimension all sides\nof the object(s).";     selectAllCheckbox.value = false;     selectAllCheckbox.onClick = function(){        if(selectAllCheckbox.value) {            // Select All is checked            topCheckbox.value = true;            topCheckbox.enabled = false;            rightCheckbox.value = true;            rightCheckbox.enabled = false;            bottomCheckbox.value = true;            bottomCheckbox.enabled = false;            leftCheckbox.value = true;            leftCheckbox.enabled = false;        } else {            // Select All is unchecked            topCheckbox.value = false;            topCheckbox.enabled = true;            rightCheckbox.value = false;            rightCheckbox.enabled = true;            bottomCheckbox.value = false;            bottomCheckbox.enabled = true;            leftCheckbox.value = false;            leftCheckbox.enabled = true;        }     }     // Options panel     optionsPanel = specifyDialogBox.add("panel", undefined, "Options");     optionsPanel.orientation = "column";     optionsPanel.margins = 20;     optionsPanel.alignChildren = "left";     // Add options panel checkboxes     (units = optionsPanel.add("checkbox", undefined, "Include units label")).helpTip = "When checked, inserts the units label\nalongside the outputted dimension.\nExample: 220 px";     units.value = true;     // If exactly 2 objects are selected, give user option to dimension BETWEEN them     if(selectedItems == 2) {        (between = optionsPanel.add("checkbox", undefined, "Dimension between objects")).helpTip = "When checked, return the\ndistance between the 2 objects\nfor the selected dimensions.";        between.value = false;     }      (showAdvancedCheckbox = optionsPanel.add("checkbox", undefined, "Enable Advanced Options")).helpTip = "Click to enable Advanced Options.";     showAdvancedCheckbox.value = false;     showAdvancedCheckbox.onClick = function(){        if(showAdvancedCheckbox.value) {            // Checked            fontSizeInput.enabled = true;            colorInputRed.enabled = true;            colorInputGreen.enabled = true;            colorInputBlue.enabled = true;            advancedOptionsPanel.show();        } else {            // Unchecked            resetAdvancedOptions();            advancedOptionsPanel.hide();        }    }      // Advanced Options panel     advancedOptionsPanel = specifyDialogBox.add("panel", undefined, "Advanced Options");     advancedOptionsPanel.orientation = "column";     advancedOptionsPanel.margins = 20;     advancedOptionsPanel.alignChildren = "left";     advancedOptionsPanel.hide();     // Add font-size box     fontGroup = advancedOptionsPanel.add("group");     fontGroup.orientation = "row";     fontLabel = fontGroup.add("statictext", undefined, "Font size:");     (fontSizeInput = fontGroup.add("edittext", undefined, "8")).helpTip = "Enter the desired font size\nfor the spec label(s).\nDefault: 8";     fontSizeInput.characters = 3;     fontSizeInput.enabled = false;      // Add color boxes     colorGroup = advancedOptionsPanel.add("group");     colorGroup.orientation = "row";     colorLabel = colorGroup.add("statictext", undefined, "Label color (RGB):");     // Red     (colorInputRed = colorGroup.add("edittext", undefined, "255")).helpTip = "Enter the RGB red color\nto use for dimension label(s).\nDefault: 255";      colorInputRed.characters = 3;     colorInputRed.enabled = false;          // Green     (colorInputGreen = colorGroup.add("edittext", undefined, "51")).helpTip = "Enter the RGB green color\nto use for dimension label(s).\nDefault: 51";      colorInputGreen.characters = 3;     colorInputGreen.enabled = false;           // Blue     (colorInputBlue = colorGroup.add("edittext", undefined, "255")).helpTip = "Enter the RGB blue color\nto use for dimension label(s).\nDefault: 255";      colorInputBlue.characters = 3;     colorInputBlue.enabled = false;          function resetAdvancedOptions() {         fontSizeInput.text = 8;         fontSizeInput.enabled = false;                  colorInputRed.text = 255;         colorInputRed.enabled = false;                  colorInputGreen.text = 51;         colorInputGreen.enabled = false;                  colorInputBlue.text = 255;         colorInputBlue.enabled = false;     }         // Button group     buttonGroup = specifyDialogBox.add("group");     buttonGroup.orientation = "row";     buttonGroup.alignment = "right";     buttonGroup.margins = 20;     // Cancel button     cancelButton = buttonGroup.add("button", undefined, "Cancel");     cancelButton.onClick = function(){        specifyDialogBox.close();     }     // Specify button     specifyButton = buttonGroup.add("button", undefined, "Specify Object(s)");     specifyButton.size = [125, 50];     specifyDialogBox.defaultElement = specifyButton;     specifyButton.onClick = function(){        startSpec();     }     /*=====  End of Create Dialog  ======*/      // SPEC layer     try {          var specsLayer = doc.layers["SPECS"];     } catch(err) {          var specsLayer = doc.layers.add();          specsLayer.name = "SPECS";     }     // measurement line and text color in RGB     var color = new RGBColor;     // color.red = colorInputRed.text;     // color.green = colorInputGreen.text;     // color.blue = colorInputBlue.text;     // gap between measurement lines and object     var gap = 4;     // size of perpendicular measurement lines.     var size = 6;     // number of decimal places in measurement     var decimals = 3;     // pixels per inch     var dpi = 300;     // Start the spec     function startSpec() {          // Add all selected objects to array          var objectsToSpec = new Array();          for(var index=doc.selection.length-1; index>=0; index--) {               objectsToSpec[index] = doc.selection[index];          }          // Fetch desired dimensions          var top = topCheckbox.value;          var left = leftCheckbox.value;          var right = rightCheckbox.value;          var bottom = bottomCheckbox.value;          // Take focus away from fontSizeInput to validate (numeric)          fontSizeInput.active = false;                    // Set bool for numeric vars          var validFontSize = /^[0-9]+$/.test(fontSizeInput.text);                    var validRedColor = /^[0-9]{1,3}$/.test(colorInputRed.text);          var validGreenColor = /^[0-9]{1,3}$/.test(colorInputGreen.text);          var validBlueColor = /^[0-9]{1,3}$/.test(colorInputBlue.text);          // If colors are valid, set variables          if(validRedColor && validGreenColor && validBlueColor){                color.red = colorInputRed.text;                color.green = colorInputGreen.text;                color.blue = colorInputBlue.text;          }          if (selectedItems < 1) {               beep();               alert("Please select at least 1 object and try again.");               // Close dialog               specifyDialogBox.close();          } else if(!top && !left && !right && !bottom) {              beep();              alert("Please select at least 1 dimension to draw.");          } else if(!validFontSize) {              // If fontSizeInput.text is not numeric              beep();              alert("Please enter a valid font size.");              fontSizeInput.active = true;              fontSizeInput.text = 8;          } else if(parseInt(fontSizeInput.text, 10) < 1) {              beep();              alert("Font size must be greater than zero.");              fontSizeInput.active = true;          } else if(!validRedColor || !validGreenColor || !validBlueColor) {              // If RGB inputs are not numeric              beep();              alert("Please enter a valid RGB color.");              colorInputRed.active = true;              colorInputRed.text = 255;              colorInputGreen.text = 51;              colorInputBlue.text = 255;          } else if (selectedItems == 2 && between.value) {               if(top) specDouble( objectsToSpec[0], objectsToSpec[1], "Top" );               if(left) specDouble( objectsToSpec[0], objectsToSpec[1], "Left" );               if(right) specDouble( objectsToSpec[0], objectsToSpec[1], "Right" );               if(bottom) specDouble( objectsToSpec[0], objectsToSpec[1], "Bottom" );               // Close dialog when finished               specifyDialogBox.close();          } else {               // Iterate over each selected object, creating individual dimensions as you go               for(var objIndex=objectsToSpec.length-1; objIndex>=0; objIndex--){                   if(top) specSingle( objectsToSpec[objIndex].geometricBounds, "Top" );                   if(left) specSingle( objectsToSpec[objIndex].geometricBounds, "Left" );                   if(right) specSingle( objectsToSpec[objIndex].geometricBounds, "Right" );                   if(bottom) specSingle( objectsToSpec[objIndex].geometricBounds, "Bottom" );               }               // Close dialog when finished               specifyDialogBox.close();          }     }     // spec a single object     function specSingle( bound, where ) {          specsLayer.locked = false;          // width and height          var w = bound[2]-bound[0];          var h = bound[1]-bound[3];          // a & b are the horizontal or vertical positions that change          // c is the horizontal or vertical position that doesn't change          var a = bound[0];          var b = bound[2];          var c = bound[1];          // xy='x' (horizontal measurement), xy='y' (vertical measurement)          var xy = "x";          // a direction flag for placing the measurement lines.          var dir = 1;          switch( where ) {               case "Top":                    a = bound[0];                    b = bound[2];                    c = bound[1];                    xy = "x";                    dir = 1;                    break;               case "Right":                    a = bound[1];                    b = bound[3];                    c = bound[2];                    xy = "y";                    dir = 1;                    break;               case "Bottom":                    a = bound[0];                    b = bound[2];                    c = bound[3];                    xy = "x";                    dir = -1;                    break;               case "Left":                    a = bound[1];                    b = bound[3];                    c = bound[0];                    xy = "y";                    dir = -1;                    break;          }          // create the measurement lines          var lines = new Array();          // horizontal measurement          if (xy=="x") {               // 2 vertical lines               lines[0]= new Array( new Array(a, c+(gap)*dir) );               lines[0].push ( new Array(a, c+(gap+size)*dir) );               lines[1]= new Array( new Array(b, c+(gap)*dir) );               lines[1].push( new Array(b, c+(gap+size)*dir) );               // 1 horizontal line               lines[2]= new Array( new Array(a, c+(gap+size/2)*dir ) );               lines[2].push( new Array(b, c+(gap+size/2)*dir ) );               // create text label               if (where=="Top") {                    var t = specLabel( w, (a+b)/2, lines[0][1][1], color );                    t.top += t.height;               } else {                    var t = specLabel( w, (a+b)/2, lines[0][0][1], color );                    t.top -= t.height;               }               t.left -= t.width/2;          // vertical measurement          } else {               // 2 horizontal lines               lines[0]= new Array( new Array( c+(gap)*dir, a) );               lines[0].push ( new Array( c+(gap+size)*dir, a) );               lines[1]= new Array( new Array( c+(gap)*dir, b) );               lines[1].push( new Array( c+(gap+size)*dir, b) );               //1 vertical line               lines[2]= new Array( new Array(c+(gap+size/2)*dir, a) );               lines[2].push( new Array(c+(gap+size/2)*dir, b) );               // create text label               if (where=="Left") {                    var t = specLabel( h, lines[0][1][0], (a+b)/2, color );                    t.left -= t.width;               } else {                    var t = specLabel( h, lines[0][0][0], (a+b)/2, color );                    t.left += size;               }               t.top += t.height/2;          }          // draw the lines          var specgroup = new Array(t);          for (var i=0; i<lines.length; i++) {               var p = doc.pathItems.add();               p.setEntirePath ( lines[i] );               setLineStyle( p, color );               specgroup.push( p );          }          group(specsLayer, specgroup );          specsLayer.locked = true;     }      // Spec the gap between 2 elements     function specDouble( item1, item2, where ) {          var bound = new Array(0,0,0,0);          var a =  item1.geometricBounds;          var b =  item2.geometricBounds;          if (where=="Top" || where=="Bottom") {               if (b[0]>a[0]) { // item 2 on right,                    if (b[0]>a[2]) { // no overlap                         bound[0] =a[2];                         bound[2] = b[0];                    } else { // overlap                         bound[0] =b[0];                         bound[2] = a[2];                    }               } else if (a[0]>=b[0]){ // item 1 on right                    if (a[0]>b[2]) { // no overlap                         bound[0] =b[2];                         bound[2] = a[0];                    } else { // overlap                         bound[0] =a[0];                         bound[2] = b[2];                    }               }               bound[1] = Math.max (a[1], b[1]);               bound[3] = Math.min (a[3], b[3]);          } else {               if (b[3]>a[3]) { // item 2 on top                    if (b[3]>a[1]) { // no overlap                         bound[3] =a[1];                         bound[1] = b[3];                    } else { // overlap                         bound[3] =b[3];                         bound[1] = a[1];                    }               } else if (a[3]>=b[3]){ // item 1 on top                    if (a[3]>b[1]) { // no overlap                         bound[3] =b[1];                         bound[1] = a[3];                    } else { // overlap                         bound[3] =a[3];                         bound[1] = b[1];                    }               }               bound[0] = Math.min(a[0], b[0]);               bound[2] = Math.max (a[2], b[2]);          }          specSingle(bound, where );     }     // Create a text label that specify the dimension     function specLabel( val, x, y, color) {               var t = doc.textFrames.add();               // Get font size from specifyDialogBox.fontSizeInput               var labelFontSize;               if( parseInt(fontSizeInput.text) > 0) {                   labelFontSize = parseInt(fontSizeInput.text);               } else {                   labelFontSize = 8;               }               t.textRange.characterAttributes.size = labelFontSize;               t.textRange.characterAttributes.alignment = StyleRunAlignmentType.center;               t.textRange.characterAttributes.fillColor = color;               // Conversions : http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/illustrator/sdk/CC2014/Illustrator%20Scripting%20Guide.pdf               // UnitValue object (page 230): http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/scripting/pdfs/javascript_tools_guide.pdf               var displayUnitsLabel = units.value;               var v = val;               var unitsLabel = "";               switch (doc.rulerUnits) {                    case RulerUnits.Picas:                         v = new UnitValue(v, "pt").as("pc");                         var vd = v - Math.floor (v);                         vd = 12*vd;                         v =  Math.floor(v)+"p"+vd.toFixed (decimals);                         break;                    case RulerUnits.Inches:                         v = new UnitValue(v, "pt").as("in");                         v = v.toFixed (decimals);                         unitsLabel = " in"; // add abbreviation                         break;                    case RulerUnits.Millimeters:                         v = new UnitValue(v, "pt").as("mm");                         v = v.toFixed (decimals);                         unitsLabel = " mm"; // add abbreviation                         break;                    case RulerUnits.Centimeters:                         v = new UnitValue(v, "pt").as("cm");                         v = v.toFixed (decimals);                         unitsLabel = " cm"; // add abbreviation                         break;                    case RulerUnits.Pixels:                         v = new UnitValue(v, "pt").as("px");                         v = v.toFixed (decimals);                         unitsLabel = " px"; // add abbreviation                         break;                    default:                         v = new UnitValue(v, "pt").as("pt");                         v = v.toFixed (decimals);                         unitsLabel = " pt"; // add abbreviation               }               if(displayUnitsLabel) {                    t.contents = v + unitsLabel;               } else {                    t.contents = v;               }               t.top = y;               t.left = x;               return t;     }     function setLineStyle(path, color) {               path.filled = false;               path.stroked = true;               path.strokeColor = color;               path.strokeWidth = 0.5;               return path;     }     // Group items in a layer     function group( layer, items, isDuplicate) {          // create new group          var gg = layer.groupItems.add();          // add to group          // reverse count, because items length is reduced as items are moved to new group          for(var i=items.length-1; i>=0; i--) {               if (items[i]!=gg) { // don't group the group itself                    if (isDuplicate) {                         newItem = items[i].duplicate (gg, ElementPlacement.PLACEATBEGINNING);                    } else {                         items[i].move( gg, ElementPlacement.PLACEATBEGINNING );                    }               }          }          return gg;     }     /*     ** ======================================     ** RUN SCRIPT     ** ======================================     */     switch (selectedItems) {          case 0:               beep();               alert("Please select at least 1 object and try again.");               break;          default:               specifyDialogBox.show();               break;     }} else { // No active document     alert("There are no objects to Specify. \nPlease open a document to continue.")}